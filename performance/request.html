<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.32">
    <link rel="manifest" href="/blog/manifest.webmanifest"><meta name="theme-color" content="#3eaf7c"><link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileColor" content="#000000"><title>请求和响应优化 | 斌</title><meta name="description" content="斌的学习记录">
    <link rel="modulepreload" href="/blog/assets/app.5be05241.js"><link rel="modulepreload" href="/blog/assets/request.html.9f43df4d.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/blog/assets/request.html.5c46e996.js">
    <link rel="stylesheet" href="/blog/assets/style.56166ae7.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><!----><span class="site-name">斌</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/review/html" class="" aria-label="前端基础/面试"><!--[--><!--]--> 前端基础/面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/vue/example/" class="" aria-label="Vue源码分析"><!--[--><!--]--> Vue源码分析 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/vue-next/reactive/" class="" aria-label="vue-next"><!--[--><!--]--> vue-next <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/react/tinyReact/" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/ts/challenge/" class="" aria-label="typescript"><!--[--><!--]--> typescript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/micro-front/intro/" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/performance/" class="router-link-active" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/idenet/blog" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/review/html" class="" aria-label="前端基础/面试"><!--[--><!--]--> 前端基础/面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/vue/example/" class="" aria-label="Vue源码分析"><!--[--><!--]--> Vue源码分析 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/vue-next/reactive/" class="" aria-label="vue-next"><!--[--><!--]--> vue-next <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/react/tinyReact/" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/ts/challenge/" class="" aria-label="typescript"><!--[--><!--]--> typescript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/micro-front/intro/" class="" aria-label="微前端"><!--[--><!--]--> 微前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/performance/" class="router-link-active" aria-label="性能优化"><!--[--><!--]--> 性能优化 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/idenet/blog" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p class="sidebar-item sidebar-heading">性能优化 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/performance/" class="router-link-active sidebar-item" aria-label="前端性能优化"><!--[--><!--]--> 前端性能优化 <!--[--><!--]--></a><!----></li><li><a href="/blog/performance/lifecycle.html" class="sidebar-item" aria-label="生命周期"><!--[--><!--]--> 生命周期 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="请求和响应优化" tabindex="-1"><a class="header-anchor" href="#请求和响应优化" aria-hidden="true">#</a> 请求和响应优化</h1><p>核心思路</p><ol><li>更好的链接传输效率</li><li>更少的请求数量</li><li>更小的资源大小</li><li>合适的缓存策略</li></ol><p>最佳实践</p><ol><li>减少DNS查找</li><li>重用tcp链接</li><li>减少http重定向</li><li>压缩资源传输</li><li>使用缓存</li><li>使用cdn</li><li>删除没必要的资源请求</li><li>在客户端缓存资源</li><li>内容在传输前先压缩</li><li>并行处理请求和响应</li><li>升级到http2.0</li><li>服务端渲染</li><li>采用预渲染的方式加快加载静态页面</li></ol><h2 id="dns-解析" tabindex="-1"><a class="header-anchor" href="#dns-解析" aria-hidden="true">#</a> dns 解析</h2><p><strong>dns-prefetch</strong> 是尝试在请求资源之前解析域名，域名解析和内容加载是串行的网络，所以这个方式能介绍用户等待时间</p><p>使用cdn加速域名，这块在服务端尤其重要，因为cdn一般多个地点配置服务器，离用户越近越好</p><h2 id="http长连接" tabindex="-1"><a class="header-anchor" href="#http长连接" aria-hidden="true">#</a> http长连接</h2><p>在http1.0时期，为了不频繁的建立和断开连接，有些浏览器在请求时，用了一个非标准的字段</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Connection: keep-alive
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这个字段要求服务器不要关闭连接</p><p>半年后http1.1发布引入了持久连接，即tcp默认不关闭，可以被多个请求复用。不用申明字段</p><p>但是这还是有个问题，客户端发送请求后需要等待服务端响应，才能发起下一个请求。 因此1.1还引入的<strong>管道机制</strong>，这样用户可以并行的发起多个请求，不用等待 一个tcp连接可以传送多个回应，势必要有一个机制来区分属于哪个回应，这就是<code>content-Length</code>的作用，用来申明本次回应的数据长度</p><p>但是这还是有个问题，对于耗时很长的操作，服务端需要等所有操作完成，才能发送数据。因此1.1引入了’分块传输代码‘，只要在请求或回应头中具有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成</p><h3 id="长连接的缺点" tabindex="-1"><a class="header-anchor" href="#长连接的缺点" aria-hidden="true">#</a> 长连接的缺点</h3><p>虽然允许复用tcp连接，但是在同一个tcp连接里面，所有数据通信是按次序进行的。服务器只有处理完一个回应才会进行下一个回应，这就会导致排队等候。这称之为“队头堵塞”</p><h2 id="http-2" tabindex="-1"><a class="header-anchor" href="#http-2" aria-hidden="true">#</a> http/2</h2><h3 id="二进制协议" tabindex="-1"><a class="header-anchor" href="#二进制协议" aria-hidden="true">#</a> 二进制协议</h3><p>在 1.1中头信息是文本，而2则是一个彻底的二进制协议。二进制的好处是，可以定义额外的帧，并且解析方便</p><h3 id="多工" tabindex="-1"><a class="header-anchor" href="#多工" aria-hidden="true">#</a> 多工</h3><p>2里的复用tcp连接，客户端和服务端都可以同时发送多个请求和回应，而且不用按照顺序一一对应，这样就避免的队头堵塞</p><p>这样双向的、实时的通信就叫多工</p><h3 id="数据流" tabindex="-1"><a class="header-anchor" href="#数据流" aria-hidden="true">#</a> 数据流</h3><p>2中的数据包不是按顺序发送的，所以2给每一个数据包（数据流）做了一个独一无二的编号，客户端还能指定数据流的优先级，优先级越高，越早响应</p><h3 id="头信息压缩" tabindex="-1"><a class="header-anchor" href="#头信息压缩" aria-hidden="true">#</a> 头信息压缩</h3><p>http中很多字段是重复的，且需要每次发送。所以2就做了一点优化，引入了头信息压缩机制。一方面可以通过gzip压缩后发送；另一方面前后端还同时维护一张头信息表，通过索引来获取内容加快获取速度</p><h3 id="服务器推送" tabindex="-1"><a class="header-anchor" href="#服务器推送" aria-hidden="true">#</a> 服务器推送</h3><p>2允许服务器未经请求，主动向客户端发送资源，这叫服务器推送。</p><h2 id="避免重定向" tabindex="-1"><a class="header-anchor" href="#避免重定向" aria-hidden="true">#</a> 避免重定向</h2><p>重定向是由服务器发送特殊的响应而触发的，在http中定义的响应码位3xx，在一般使用中大多数重定向为登录。我们不看影响，来看看三种重定向</p><ul><li>永久重定向 301 308</li><li>临时重定向 302 303 307</li><li>特殊重定向 300 304（常用，资源未被修改，使用了缓存）</li></ul><h2 id="压缩传输的数据资源" tabindex="-1"><a class="header-anchor" href="#压缩传输的数据资源" aria-hidden="true">#</a> 压缩传输的数据资源</h2><ul><li>响应数据压缩 ：gzip</li></ul><h2 id="http-缓存" tabindex="-1"><a class="header-anchor" href="#http-缓存" aria-hidden="true">#</a> HTTP 缓存</h2><p><img src="/blog/assets/2.dcb2f1cc.png" alt="缓存使用流程图"></p><p>http缓存是最常结束的缓存之一，它可细分为m<strong>强制缓存</strong>和<strong>协商缓存</strong>，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问来判断是否需要重新请求</p><h3 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存" aria-hidden="true">#</a> 强制缓存</h3><p>和强制缓存有关的两个字段是<code>expires</code>he<code>cache-control</code>，在1.0时期会通过比较本地时间和<code>expires</code>来确定是否需要重新请求，但是这种方式存在一个很大的漏洞，如果用户对本地时间进行修改，那么对于缓存的判断就是会失误</p><p>所以在1.1时期新增了<code>cache-control</code>字段，只要设置<code>maxage=1000</code>来进行时间长度的控制，就能避免时间不同造成的问题</p><p><strong>no-cache、no-store</strong></p><p>no-store 表示完全使用最新数据，不使用缓存 no-cache 表示通过与服务器协商验证缓存有效性，若未过期，则使用本地缓存</p><p><strong>private、public</strong></p><p>public 表示响应资源即可以被浏览器缓存，也可以被代理期缓存 private 响应资源只能被浏览器缓存，若未显示指定啧默认为prite</p><p><strong>max-age、s-maxage</strong></p><p>s-maxage 表示缓存在代理服服务器上的有效性，当设置了public后，就可以设置它 且一般他会和max-age一起使用，这样来保证资源的有效性</p><h3 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h3><p><strong>last-modifed</strong></p><p>顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期</p><p>首先再使用写上缓存之前，服务端会将<code>cache-control</code>设置为<code>no-cache</code>，然后获取文件的最后修改时间，放到响应头的<code>last-modified</code>中，客户端拿到后，入伙刷新页面，就会在请求头重带上一个<code>if-modified-since</code>字段，值和<code>last-modified</code>一样，这时候服务端比较两个值，后返回新资源，还是返回304不修改，将响应体重定向到本地缓存上</p><p>last-modifed的不足：</p><ol><li>获取时间戳其文件的修改单位是秒，如果文件修改非常快，这个缓存就存在有效性问题</li><li>只改文件名，没动内容也会更新时间</li></ol><p><strong>Etag</strong></p><p>为了弥补不足，1.1新增了<code>Etag</code>，<code>Etag</code>会根据文件内容的不同生成一个hash字符串。<code>Etag</code>比<code>last-modified</code>的优先级更高，做法和之前类似，客户端也会返回一个同值的<code>if-none-match</code>来给服务端进行判断</p><p>Etag的不足</p><ol><li>需要服务器消耗资源进行hash计算</li></ol><h2 id="cdn-缓存" tabindex="-1"><a class="header-anchor" href="#cdn-缓存" aria-hidden="true">#</a> cdn 缓存</h2><p>cdn为什么设计成和主站域名不同？</p><ol><li>避免对静态资源的请求携带不必要的Cookie信息</li><li>考虑浏览器对同一域名下并发请求的限制</li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.5be05241.js" defer></script>
  </body>
</html>
