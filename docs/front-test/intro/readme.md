# 概念

我们为什么需要测试？在开发项目的过程中，我们经常会遇到以下问题

- 当一个项目经过长久的维护，当维护者不止一个人的时候，即使代码开起来没什么问题，也需要进行重复的测试，并且可能需要进行回归测试来判断对以前的功能有没有影响
- 当想对一个项目进行重构的时候，必然会花大量时间进行回归测试

以上这些问题都是由于大多数开发者所使用最基本的手动测试的方式所带来的问题，解决它的根本原因就在于引入自动化测试方案。

## 自动化测试

自动化测试（automated testing）是利用计算机程序检查软件是否运行正常的测试方法。换句话说，就是用其他额外的代码检查被测软件的代码。当测试代码编写完之后，就可以不费吹灰之力地进行无数次重复测试。

可使用许多种不同的方法来编写自动化测试脚本。

- 可以编写通过浏览器自动执行的程序
- 可以直接调用源代码里的函数
- 也可以直接对比程序渲染之后的截图

虽然每一种方法的优势各不相同，但它们有一大共同点：**相比手动测试而言节省了大量时间以及提高了程序的稳定性**。

当然不仅如此，自动化测试还有很多优点，比如：

- 尽早发现程序的bug和不足
- 增强程序员对程序健壮性和稳定性的信心
- 改进设计
- 快速反馈，减少调试时间
- 促进重构

## 测试分类

前端开发常见的测试主要有以下几种

- 单元测试：验证独立单元是否正常工作
- 集成测试：验证多个单元协同工作
- 端到端测试：从用户角度以机器的方式在真实浏览器环境验证应用交互
- 快照测试：验证程序的UI变化


### 单元测试

单元测试是对应用程序最小的部分（单元）运行测试的过程。通常，测试的单元是函数，但在前端应用中，组件也是被测单元。

单元测试可以单独调用源代码中的函数并断言其行为是否正确。

单元测试的优点

- 提升代码质量，减少bug
- 快速反馈，减少调试时间
- 让代码维护更容易
- 有助于代码的模块化设计
- 代码覆盖率高

单元测试的缺点

- 由于单元测试是独立的，所以无法保证多个单元运行到一起是正确的

### 集成测试

相当于一个用户需求的测试

优点

- 由于是从用户使用角度出发，更容易获得软件使用过程中的正确性
- 集成测试相对于写了软件的说明文档
- 由于不关注底层代码实现细节，所以更有利于快速重构
- 相比单元测试，集成测试的开发速度要更快一些

缺点

- 测试失败的时候无法快速定位问题
- 代码覆盖率较低
- 速度比单元测试要慢

### 端到端测试 e2e

E2E（end to end）端到端测试是最直观可以理解的测试类型。在前端应用程序中，端到端测试可以从用户的视角通过浏览器自动检查应用程序是否正常工作。


优点：
- 真实的测试环境，更容易获得程序的信心

缺点： 
- 首先，**端到端测试运行不够快**。启动浏览器需要占用几秒钟，网站响应速度又慢。通常一套端到端测试需要 30 分钟的运行时间。如果应用程序完全依赖于端到端测试，那么测试套件将需要数小时的运行时间。
- **端到端测试的另一个问题是调试起来比较困难**。要调试端到端测试，需要打开浏览器并逐步完成用户操作以重现 bug。本地运行这个调试过程就已经够糟糕了，如果测试是在持续集成服务器上失败而不是本地计算机上失败，那么整个调试过程会变得更加糟糕。

一些流行的端到端测试框架

- [Cypress](https://github.com/cypress-io/cypress)

### 快照测试

快照测试类似于“找不同”游戏。快照测试会给运行中的应用程序拍一张图片，并将其与以前保存的图片进行比较。如果图像不同，则测试失败。这种测试方法对确保应用程序代码变更后是否仍然可以正确渲染很有帮助。


## 如何测试

一个健康、快速、可维护的测试组合应该是这样的：

- 在底层为应用配置静态测试，比如使用 ESLint 约束代码规范、使用 TypeScript 增强类型定义
- 为应用中的特定算法或是工具函数编写小而快的单元测试
- 写许多模拟真实用户行为的集成测试，增强应用构建信心
- 为稳定的组件编写快照测试
- 为应用核心业务流程编写少量的高层次端到端测试


## 测试覆盖率

**测试覆盖率**(test coverage)是衡量软件测试**完整性**的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。

- 代码覆盖率
- 需求覆盖率

### 代码覆盖率

最著名的测试覆盖率就是代码覆盖率。这是一种面向软件开发和实现的定义。它关注的是在执行测试用例时，有哪些软件代码被执行到了，有哪些软件代码没有被执行到。**被执行的代码数量与代码总数量之间的比值，就是代码覆盖率**。

根据代码粒度的不同，分为四个方面

- 行覆盖率（line coverage）：是否每一行都执行了？
- 函数覆盖率（function coverage）：是否每个函数都调用了？
- 分支覆盖率（branch coverage）：是否每个if代码块都执行了？
- 语句覆盖率（statement coverage）：是否每个语句都执行了？


### 需求覆盖率


对于黑盒测试，例如功能测试/集成测试/系统测试等来说，测试用例通常是**基于软件需求而不是软件实现**所设计的。因此，度量这类测试完整性的手段一般是需求覆盖率，即**测试所覆盖的需求数量与总需求数量的比值**。

如何度量需求覆盖率呢？通常没有现成的工具可以使用，而需要**依赖人工计算**，尤其是需要依赖人工去标记每个测试用例和需求之间的**映射关系**。


## 测试开发方式

测试不仅能够验证软件功能、保证代码质量，也能够影响软件开发的模式。

测试开发有两个流派：

- TDD：测试驱动开发，先写测试后实现功能
- BDD：行为驱动开发，先实现功能后写测试

### TDD

TDD（Test-driven development），测试驱动开发，是敏捷开发中的一项核心实践和技术，也是一种软件设计方法论。

- 它的原理就是在编写代码之前先编写测试用例，由测试来决定我们的代码；
- 而且 TDD 更多的需要编写独立的测试用例，比如只测试一个组件的某个功能点，某个工具函数等；

**TDD的优点**

- 保证代码质量，因为先编写测试，所以可能出现的问题都被提前发现了；
- 促进开发人员思考，有利于程序的模块设计；
- 测试覆盖率高，因为后编写代码，因此测试用例基本都能照顾到；

**TDD的缺点**

- 代码量增多，大多数情况下测试代码是功能代码的两倍甚至更多；
- 业务耦合度高，测试用例中使用了业务中一些模拟的数据，当业务代码变更的时候，要去重新组织测试用例；
- 关注点过于独立，由于单元测试只关注这一个单元的健康状况，无法保证多个单元组成的整体是否正常；

### BDD

BDD（Behavior-driven development）行为驱动开发，是测试驱动开发延伸出来的一种敏捷软件开发技术。

- BDD 核心目的是为了解决 TDD 模式下开发和实际功能需求不一致而诞生；
- BDD 不需要再面向实现细节设计测试，取而代之的是面向行为来测试。
- 它是从产品角度出发，鼓励开发人员和非开发人员（产品、QA、客户等）之间的协作；
- 由于 BDD 的核心是关注软件的功能测试，所以 BDD 更多的是结合集成测试进行，它是黑盒的；

**BDD 的优点**

- 由于侧重于需求功能的完整度，所以能给开发人员增加更多对程序的信心；
- 由于仅关注功能，不关注实现细节，有利于测试代码和实际代码解耦；
- 由于大多数为编写集成测试，相比 TDD 有更好的开发效率；

**BDD 的缺点**

- 因为以功能性的集成测试为主，因此不是那么关注每个函数功能，测试覆盖率比较低；
- 没有 TDD 那么严格的保证代码质量；

## 前端自动化测试的权衡利弊

在编写测试时，请务必牢记编写测试的目的。**通常，测试的目的是为了节省时间。如果你正在进行的项目是稳定的并且会长期开发，那么测试是可以带来收益的。**

**但是如果测试编写与维护的时间长于它们可以节省的时间，那么你根本不应该编写测试。** 当然，在编写代码之前你很难知道通过测试可以节省多少时间，你会随着时间的推移去了解。但是，假设你 **正在一个短期项目中创建原型，或者是在一个创业公司迭代一个想法，那你可能不会从编写测试中获得收益。**

# vue中的测试

在使用 `@vue/cli`创建项目的时候，只要选择 `unit code`我们就能创建单元测试。这时候运行 `npm run test：unit`就能看到默认的测试成功的信息。

## Jest 默认配置

通过配置可以很清晰的看到，会测试什么，使用什么测试

```js
// node_modules/@vue/cli-plugin-unit-jest/presets/default/jest-preset.js
module.exports = {
  moduleFileExtensions: [ // 可以省略的模块扩展名
    'js',
    'jsx',
    'json',
    // tell Jest to handle *.vue files
    'vue'
  ],
  transform: { // 模块转换器
    // process *.vue files with vue-jest
    '^.+\\.vue$': require.resolve('vue-jest'), // .vue 模块使用 vue-jest 转换
    '.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$':
    require.resolve('jest-transform-stub'), // css 等模块使用 jest-transform-stub 转换为字符串
    '^.+\\.jsx?$': require.resolve('babel-jest') // .jsx 模块使用 babel-jest 转换
  },
  transformIgnorePatterns: ['/node_modules/'], // 不转换第三方包资源模块
  // support the same @ -> src alias mapping in source code
  // 支持模块加载路径中的 @ 别名
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  // 测试环境，Jest中的默认环境是通过jsdom的类似于浏览器的环境
  // 如果要构建 node 应用，则可以使用 node 选项来使用类似 node 的环境。
  // 通过在文件顶部添加 @jest-environment docblock，可以在该文件中指定另一个用于所有测试的环境
  testEnvironment: 'jest-environment-jsdom-fifteen',
  // serializer for snapshots
  
  // 序列化快照
  // 对 .vue 组件进行快照测试，快照存储为一个文件，文件内容需要格式化，这里使用 jest-serializer-vue 进行格式化处理
  snapshotSerializers: [
    'jest-serializer-vue'
  ],
  
  // 要测试的文件路径
  testMatch: [
    '**/tests/unit/**/*.spec.[jt]s?(x)',
    '**/__tests__/*.[jt]s?(x)'
  ],
  // 测试的浏览器环境地址
  // https://github.com/facebook/jest/issues/6766
  testURL: 'http://localhost/',
  
  // 监视运行测试的插件工具
  watchPlugins: [
    // 在监视模式下，为 p 方式筛选文件提供交互式选择文件功能
    require.resolve('jest-watch-typeahead/filename'),
    require.resolve('jest-watch-typeahead/testname')
  ]
}
```