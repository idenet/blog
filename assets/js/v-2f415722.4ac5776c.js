"use strict";(self.webpackChunkstudy_note=self.webpackChunkstudy_note||[]).push([[858],{1595:(e,a,t)=>{t.r(a),t.d(a,{data:()=>i});const i={key:"v-2f415722",path:"/performance/request.html",title:"请求和响应优化",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"dns 解析",slug:"dns-解析",children:[]},{level:2,title:"http长连接",slug:"http长连接",children:[{level:3,title:"长连接的缺点",slug:"长连接的缺点",children:[]}]},{level:2,title:"http/2",slug:"http-2",children:[{level:3,title:"二进制协议",slug:"二进制协议",children:[]},{level:3,title:"多工",slug:"多工",children:[]},{level:3,title:"数据流",slug:"数据流",children:[]},{level:3,title:"头信息压缩",slug:"头信息压缩",children:[]},{level:3,title:"服务器推送",slug:"服务器推送",children:[]}]},{level:2,title:"避免重定向",slug:"避免重定向",children:[]},{level:2,title:"压缩传输的数据资源",slug:"压缩传输的数据资源",children:[]},{level:2,title:"HTTP 缓存",slug:"http-缓存",children:[{level:3,title:"强制缓存",slug:"强制缓存",children:[]},{level:3,title:"协商缓存",slug:"协商缓存",children:[]}]},{level:2,title:"cdn 缓存",slug:"cdn-缓存",children:[]}],filePathRelative:"performance/request.md",git:{updatedTime:1639231846e3}}},8367:(e,a,t)=>{t.r(a),t.d(a,{default:()=>h});var i=t(6252),l=t(5867);const d=(0,i.uE)('<h1 id="请求和响应优化" tabindex="-1"><a class="header-anchor" href="#请求和响应优化" aria-hidden="true">#</a> 请求和响应优化</h1><p>核心思路</p><ol><li>更好的链接传输效率</li><li>更少的请求数量</li><li>更小的资源大小</li><li>合适的缓存策略</li></ol><p>最佳实践</p><ol><li>减少DNS查找</li><li>重用tcp链接</li><li>减少http重定向</li><li>压缩资源传输</li><li>使用缓存</li><li>使用cdn</li><li>删除没必要的资源请求</li><li>在客户端缓存资源</li><li>内容在传输前先压缩</li><li>并行处理请求和响应</li><li>升级到http2.0</li><li>服务端渲染</li><li>采用预渲染的方式加快加载静态页面</li></ol><h2 id="dns-解析" tabindex="-1"><a class="header-anchor" href="#dns-解析" aria-hidden="true">#</a> dns 解析</h2><p><strong>dns-prefetch</strong> 是尝试在请求资源之前解析域名，域名解析和内容加载是串行的网络，所以这个方式能介绍用户等待时间</p><p>使用cdn加速域名，这块在服务端尤其重要，因为cdn一般多个地点配置服务器，离用户越近越好</p><h2 id="http长连接" tabindex="-1"><a class="header-anchor" href="#http长连接" aria-hidden="true">#</a> http长连接</h2><p>在http1.0时期，为了不频繁的建立和断开连接，有些浏览器在请求时，用了一个非标准的字段</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>Connection: keep-alive\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这个字段要求服务器不要关闭连接</p><p>半年后http1.1发布引入了持久连接，即tcp默认不关闭，可以被多个请求复用。不用申明字段</p><p>但是这还是有个问题，客户端发送请求后需要等待服务端响应，才能发起下一个请求。 因此1.1还引入的<strong>管道机制</strong>，这样用户可以并行的发起多个请求，不用等待 一个tcp连接可以传送多个回应，势必要有一个机制来区分属于哪个回应，这就是<code>content-Length</code>的作用，用来申明本次回应的数据长度</p><p>但是这还是有个问题，对于耗时很长的操作，服务端需要等所有操作完成，才能发送数据。因此1.1引入了’分块传输代码‘，只要在请求或回应头中具有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成</p><h3 id="长连接的缺点" tabindex="-1"><a class="header-anchor" href="#长连接的缺点" aria-hidden="true">#</a> 长连接的缺点</h3><p>虽然允许复用tcp连接，但是在同一个tcp连接里面，所有数据通信是按次序进行的。服务器只有处理完一个回应才会进行下一个回应，这就会导致排队等候。这称之为“队头堵塞”</p><h2 id="http-2" tabindex="-1"><a class="header-anchor" href="#http-2" aria-hidden="true">#</a> http/2</h2><h3 id="二进制协议" tabindex="-1"><a class="header-anchor" href="#二进制协议" aria-hidden="true">#</a> 二进制协议</h3><p>在 1.1中头信息是文本，而2则是一个彻底的二进制协议。二进制的好处是，可以定义额外的帧，并且解析方便</p><h3 id="多工" tabindex="-1"><a class="header-anchor" href="#多工" aria-hidden="true">#</a> 多工</h3><p>2里的复用tcp连接，客户端和服务端都可以同时发送多个请求和回应，而且不用按照顺序一一对应，这样就避免的队头堵塞</p><p>这样双向的、实时的通信就叫多工</p><h3 id="数据流" tabindex="-1"><a class="header-anchor" href="#数据流" aria-hidden="true">#</a> 数据流</h3><p>2中的数据包不是按顺序发送的，所以2给每一个数据包（数据流）做了一个独一无二的编号，客户端还能指定数据流的优先级，优先级越高，越早响应</p><h3 id="头信息压缩" tabindex="-1"><a class="header-anchor" href="#头信息压缩" aria-hidden="true">#</a> 头信息压缩</h3><p>http中很多字段是重复的，且需要每次发送。所以2就做了一点优化，引入了头信息压缩机制。一方面可以通过gzip压缩后发送；另一方面前后端还同时维护一张头信息表，通过索引来获取内容加快获取速度</p><h3 id="服务器推送" tabindex="-1"><a class="header-anchor" href="#服务器推送" aria-hidden="true">#</a> 服务器推送</h3><p>2允许服务器未经请求，主动向客户端发送资源，这叫服务器推送。</p><h2 id="避免重定向" tabindex="-1"><a class="header-anchor" href="#避免重定向" aria-hidden="true">#</a> 避免重定向</h2><p>重定向是由服务器发送特殊的响应而触发的，在http中定义的响应码位3xx，在一般使用中大多数重定向为登录。我们不看影响，来看看三种重定向</p><ul><li>永久重定向 301 308</li><li>临时重定向 302 303 307</li><li>特殊重定向 300 304（常用，资源未被修改，使用了缓存）</li></ul><h2 id="压缩传输的数据资源" tabindex="-1"><a class="header-anchor" href="#压缩传输的数据资源" aria-hidden="true">#</a> 压缩传输的数据资源</h2><ul><li>响应数据压缩 ：gzip</li></ul><h2 id="http-缓存" tabindex="-1"><a class="header-anchor" href="#http-缓存" aria-hidden="true">#</a> HTTP 缓存</h2><p><img src="'+l+'" alt="缓存使用流程图"></p><p>http缓存是最常结束的缓存之一，它可细分为m<strong>强制缓存</strong>和<strong>协商缓存</strong>，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问来判断是否需要重新请求</p><h3 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存" aria-hidden="true">#</a> 强制缓存</h3><p>和强制缓存有关的两个字段是<code>expires</code>he<code>cache-control</code>，在1.0时期会通过比较本地时间和<code>expires</code>来确定是否需要重新请求，但是这种方式存在一个很大的漏洞，如果用户对本地时间进行修改，那么对于缓存的判断就是会失误</p><p>所以在1.1时期新增了<code>cache-control</code>字段，只要设置<code>maxage=1000</code>来进行时间长度的控制，就能避免时间不同造成的问题</p><p><strong>no-cache、no-store</strong></p><p>no-store 表示完全使用最新数据，不使用缓存 no-cache 表示通过与服务器协商验证缓存有效性，若未过期，则使用本地缓存</p><p><strong>private、public</strong></p><p>public 表示响应资源即可以被浏览器缓存，也可以被代理期缓存 private 响应资源只能被浏览器缓存，若未显示指定啧默认为prite</p><p><strong>max-age、s-maxage</strong></p><p>s-maxage 表示缓存在代理服服务器上的有效性，当设置了public后，就可以设置它 且一般他会和max-age一起使用，这样来保证资源的有效性</p><h3 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h3><p><strong>last-modifed</strong></p><p>顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期</p><p>首先再使用写上缓存之前，服务端会将<code>cache-control</code>设置为<code>no-cache</code>，然后获取文件的最后修改时间，放到响应头的<code>last-modified</code>中，客户端拿到后，入伙刷新页面，就会在请求头重带上一个<code>if-modified-since</code>字段，值和<code>last-modified</code>一样，这时候服务端比较两个值，后返回新资源，还是返回304不修改，将响应体重定向到本地缓存上</p><p>last-modifed的不足：</p><ol><li>获取时间戳其文件的修改单位是秒，如果文件修改非常快，这个缓存就存在有效性问题</li><li>只改文件名，没动内容也会更新时间</li></ol><p><strong>Etag</strong></p><p>为了弥补不足，1.1新增了<code>Etag</code>，<code>Etag</code>会根据文件内容的不同生成一个hash字符串。<code>Etag</code>比<code>last-modified</code>的优先级更高，做法和之前类似，客户端也会返回一个同值的<code>if-none-match</code>来给服务端进行判断</p><p>Etag的不足</p><ol><li>需要服务器消耗资源进行hash计算</li></ol><h2 id="cdn-缓存" tabindex="-1"><a class="header-anchor" href="#cdn-缓存" aria-hidden="true">#</a> cdn 缓存</h2><p>cdn为什么设计成和主站域名不同？</p><ol><li>避免对静态资源的请求携带不必要的Cookie信息</li><li>考虑浏览器对同一域名下并发请求的限制</li></ol>',59),r={},h=(0,t(3744).Z)(r,[["render",function(e,a){return d}]])},3744:(e,a)=>{a.Z=(e,a)=>{const t=e.__vccOpts||e;for(const[e,i]of a)t[e]=i;return t}},5867:(e,a,t)=>{e.exports=t.p+"assets/img/2.ab2148ae.png"}}]);