"use strict";(self.webpackChunkstudy_note=self.webpackChunkstudy_note||[]).push([[424],{9074:(e,l,i)=>{i.r(l),i.d(l,{data:()=>t});const t={key:"v-bbe195b2",path:"/performance/lifecycle.html",title:"生命周期",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"网络请求线程开启",slug:"网络请求线程开启",children:[]},{level:2,title:"建立http请求",slug:"建立http请求",children:[]},{level:2,title:"dns 解析",slug:"dns-解析",children:[]},{level:2,title:"tcp连接",slug:"tcp连接",children:[]},{level:2,title:"反向代理",slug:"反向代理",children:[]},{level:2,title:"http协议",slug:"http协议",children:[]},{level:2,title:"浏览器缓存",slug:"浏览器缓存",children:[]},{level:2,title:"生成页面",slug:"生成页面",children:[]}],filePathRelative:"performance/lifecycle.md",git:{updatedTime:1639231846e3}}},6924:(e,l,i)=>{i.r(l),i.d(l,{default:()=>h});const t=(0,i(6252).uE)('<h1 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h1><p><strong>一道前端面试题</strong></p><p>从浏览器地址栏输入url后，到页面渲染出来，整个过程发生了什么。</p><p>这个问题可以回答的非常细致，我们可以从几个方面入手，再来细分</p><ol><li>浏览器接收到url，到url请求开启线程（进程与线程）</li><li>一个完整的http请求并发出（解析并建立请求）</li><li>服务器接收到请求并转交给具体的后台处理（前后端交互）</li><li>前后端之间的http交互和涉及到的缓存机制</li><li>浏览器接收到数据包后的关键路径渲染</li><li>js引擎解析过程</li></ol><h2 id="网络请求线程开启" tabindex="-1"><a class="header-anchor" href="#网络请求线程开启" aria-hidden="true">#</a> 网络请求线程开启</h2><p>首先对url进行解析，如果是http协议，则浏览器开新建一个网络请求线程 去下载所需的资源。</p><p>这里注意一下线程和进程的区别。进程是沙箱隔离的，而进程中的线程是共享同一个进程的数据，进程间的通讯通过 IPC 机制</p><p>在chrome没出现以前，所有的浏览器都是单进程的，这时候一个页面死了，整个浏览器就block了。自从chrome出现后，就都是多进程的浏览器了。</p><p>主要分为以下几个进程</p><p>浏览器主进程 一个浏览器只有一个主进程，主要负责菜单栏，标题栏显示，文件访问，前进后退，子进程管理等 渲染进程（沙箱模式）<strong>默认回味每个标签窗口页开启一个独立渲染的进程</strong>，其中包括多个子线程，js引擎，gui渲染，事件触发，定时器触发 插件进程（沙箱模式）主要为了安全，让恶意脚本无法读取敏感数据 GPU进程 为了实现3d效果的css引入，所以每次问到如何开启gpu，只要开启css的3d效果就行了 网络进程 负责网络资源的加载</p><h2 id="建立http请求" tabindex="-1"><a class="header-anchor" href="#建立http请求" aria-hidden="true">#</a> 建立http请求</h2><p>这个阶段主要分为两个部分</p><ol><li>首先发起请求的客户端浏览器要明确知道所要访问的服务器地址</li><li>然后尽力通过该服务器地址的路径</li></ol><h2 id="dns-解析" tabindex="-1"><a class="header-anchor" href="#dns-解析" aria-hidden="true">#</a> dns 解析</h2><p>dns解析非常耗时，所以在浏览器，本机本地都做了dns的缓存，以快速的获取相应 下面这张图可以很好的说明解析过程</p><p><a href="../images/performance/1.jpg">dns解析</a></p><h2 id="tcp连接" tabindex="-1"><a class="header-anchor" href="#tcp连接" aria-hidden="true">#</a> tcp连接</h2><p>tcp连接的关键点就在于三次握手和4次挥手。</p><p>握手</p><ol><li>请求建立连接</li><li>服务端接收到请求连接数据包后，重整数据包返回给客户端作为确认</li><li>客户端队确认进行应答</li></ol><p>挥手</p><ol><li>客户端发出请求断开连接的数据包</li><li>服务端告知客户端已收到，但是因为数据可能未接收完成，客户端继续等待</li><li>服务端已完成所有数据的接收，则发送一个确认关闭的数据包</li><li>客户端进行关闭操作，并再次发送一个确认的数据包，告知我这边已经关闭，这时候服务端才会真正关闭</li></ol><h2 id="反向代理" tabindex="-1"><a class="header-anchor" href="#反向代理" aria-hidden="true">#</a> 反向代理</h2><p>当建立好tcp连接后，前后端就能进行通信了，但是往往之间会加入反向代理。因为一个应用是很复杂的，服务端往往会有多个服务来支持整个系统，这时候就会有一个统一的反向代理服务器来做负载均衡的操作。反向代理服务器的作用</p><ul><li>负载均衡</li><li>安全防火墙</li><li>加密及ssl加速</li><li>数据压缩</li><li>解决跨域</li><li>对静态资源的缓存</li></ul><p>常用的有nginx、iis、apache</p><h2 id="http协议" tabindex="-1"><a class="header-anchor" href="#http协议" aria-hidden="true">#</a> http协议</h2><p>http经过几次发展，从1.0 -&gt; 1.1 -&gt; 2.0，进行了长连接，多路复用，压缩报文等改进。后面会详细论述</p><h2 id="浏览器缓存" tabindex="-1"><a class="header-anchor" href="#浏览器缓存" aria-hidden="true">#</a> 浏览器缓存</h2><p>在基于网络的前后端交互过程中，使用缓存能有效提高性能。具体的缓存策略分为，强缓存和协商缓存</p><h2 id="生成页面" tabindex="-1"><a class="header-anchor" href="#生成页面" aria-hidden="true">#</a> 生成页面</h2><p>当从服务器拿到页面之后，浏览器会解析html和css，通过渲染进程来构建 DOM对象模型和cssOM，然后将两个模型合并为渲染树，最终生成为html</p>',33),a={},h=(0,i(3744).Z)(a,[["render",function(e,l){return t}]])},3744:(e,l)=>{l.Z=(e,l)=>{const i=e.__vccOpts||e;for(const[e,t]of l)i[e]=t;return i}}}]);