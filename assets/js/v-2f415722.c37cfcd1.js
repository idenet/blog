"use strict";(self.webpackChunkstudy_note=self.webpackChunkstudy_note||[]).push([[8858],{1595:(l,e,n)=>{n.r(e),n.d(e,{data:()=>t});const t={key:"v-2f415722",path:"/performance/request.html",title:"请求和响应优化",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"dns 解析",slug:"dns-解析",children:[]},{level:2,title:"http长连接",slug:"http长连接",children:[{level:3,title:"长连接的缺点",slug:"长连接的缺点",children:[]}]},{level:2,title:"http/2",slug:"http-2",children:[{level:3,title:"二进制协议",slug:"二进制协议",children:[]},{level:3,title:"多工",slug:"多工",children:[]},{level:3,title:"数据流",slug:"数据流",children:[]},{level:3,title:"头信息压缩",slug:"头信息压缩",children:[]},{level:3,title:"服务器推送",slug:"服务器推送",children:[]}]},{level:2,title:"避免重定向",slug:"避免重定向",children:[]},{level:2,title:"压缩传输的数据资源",slug:"压缩传输的数据资源",children:[]},{level:2,title:"HTTP 缓存",slug:"http-缓存",children:[{level:3,title:"强制缓存",slug:"强制缓存",children:[]},{level:3,title:"协商缓存",slug:"协商缓存",children:[]}]},{level:2,title:"cdn 缓存",slug:"cdn-缓存",children:[]}],filePathRelative:"performance/request.md",git:{updatedTime:1639231809e3}}},8367:(l,e,n)=>{n.r(e),n.d(e,{default:()=>cl});var t=n(6252),a=n(5867);const i=(0,t._)("h1",{id:"请求和响应优化",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#请求和响应优化","aria-hidden":"true"},"#"),(0,t.Uk)(" 请求和响应优化")],-1),d=(0,t._)("p",null,"核心思路",-1),u=(0,t._)("ol",null,[(0,t._)("li",null,"更好的链接传输效率"),(0,t._)("li",null,"更少的请求数量"),(0,t._)("li",null,"更小的资源大小"),(0,t._)("li",null,"合适的缓存策略")],-1),r=(0,t._)("p",null,"最佳实践",-1),h=(0,t._)("ol",null,[(0,t._)("li",null,"减少DNS查找"),(0,t._)("li",null,"重用tcp链接"),(0,t._)("li",null,"减少http重定向"),(0,t._)("li",null,"压缩资源传输"),(0,t._)("li",null,"使用缓存"),(0,t._)("li",null,"使用cdn"),(0,t._)("li",null,"删除没必要的资源请求"),(0,t._)("li",null,"在客户端缓存资源"),(0,t._)("li",null,"内容在传输前先压缩"),(0,t._)("li",null,"并行处理请求和响应"),(0,t._)("li",null,"升级到http2.0"),(0,t._)("li",null,"服务端渲染"),(0,t._)("li",null,"采用预渲染的方式加快加载静态页面")],-1),_=(0,t._)("h2",{id:"dns-解析",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#dns-解析","aria-hidden":"true"},"#"),(0,t.Uk)(" dns 解析")],-1),c=(0,t._)("p",null,[(0,t._)("strong",null,"dns-prefetch"),(0,t.Uk)(" 是尝试在请求资源之前解析域名，域名解析和内容加载是串行的网络，所以这个方式能介绍用户等待时间")],-1),s=(0,t._)("p",null,"使用cdn加速域名，这块在服务端尤其重要，因为cdn一般多个地点配置服务器，离用户越近越好",-1),o=(0,t._)("h2",{id:"http长连接",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#http长连接","aria-hidden":"true"},"#"),(0,t.Uk)(" http长连接")],-1),p=(0,t._)("p",null,"在http1.0时期，为了不频繁的建立和断开连接，有些浏览器在请求时，用了一个非标准的字段",-1),k=(0,t._)("div",{class:"language-text ext-text line-numbers-mode"},[(0,t._)("pre",{class:"language-text"},[(0,t._)("code",null,"Connection: keep-alive\n")]),(0,t._)("div",{class:"line-numbers"},[(0,t._)("span",{class:"line-number"},"1"),(0,t._)("br")])],-1),g=(0,t._)("p",null,"这个字段要求服务器不要关闭连接",-1),U=(0,t._)("p",null,"半年后http1.1发布引入了持久连接，即tcp默认不关闭，可以被多个请求复用。不用申明字段",-1),f=(0,t._)("p",null,[(0,t.Uk)("但是这还是有个问题，客户端发送请求后需要等待服务端响应，才能发起下一个请求。 因此1.1还引入的"),(0,t._)("strong",null,"管道机制"),(0,t.Uk)("，这样用户可以并行的发起多个请求，不用等待 一个tcp连接可以传送多个回应，势必要有一个机制来区分属于哪个回应，这就是"),(0,t._)("code",null,"content-Length"),(0,t.Uk)("的作用，用来申明本次回应的数据长度")],-1),x=(0,t._)("p",null,[(0,t.Uk)("但是这还是有个问题，对于耗时很长的操作，服务端需要等所有操作完成，才能发送数据。因此1.1引入了’分块传输代码‘，只要在请求或回应头中具有"),(0,t._)("code",null,"Transfer-Encoding"),(0,t.Uk)("字段，就表明回应将由数量未定的数据块组成")],-1),b=(0,t._)("h3",{id:"长连接的缺点",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#长连接的缺点","aria-hidden":"true"},"#"),(0,t.Uk)(" 长连接的缺点")],-1),m=(0,t._)("p",null,"虽然允许复用tcp连接，但是在同一个tcp连接里面，所有数据通信是按次序进行的。服务器只有处理完一个回应才会进行下一个回应，这就会导致排队等候。这称之为“队头堵塞”",-1),v=(0,t._)("h2",{id:"http-2",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#http-2","aria-hidden":"true"},"#"),(0,t.Uk)(" http/2")],-1),E=(0,t._)("h3",{id:"二进制协议",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#二进制协议","aria-hidden":"true"},"#"),(0,t.Uk)(" 二进制协议")],-1),T=(0,t._)("p",null,"在 1.1中头信息是文本，而2则是一个彻底的二进制协议。二进制的好处是，可以定义额外的帧，并且解析方便",-1),C=(0,t._)("h3",{id:"多工",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#多工","aria-hidden":"true"},"#"),(0,t.Uk)(" 多工")],-1),w=(0,t._)("p",null,"2里的复用tcp连接，客户端和服务端都可以同时发送多个请求和回应，而且不用按照顺序一一对应，这样就避免的队头堵塞",-1),y=(0,t._)("p",null,"这样双向的、实时的通信就叫多工",-1),z=(0,t._)("h3",{id:"数据流",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#数据流","aria-hidden":"true"},"#"),(0,t.Uk)(" 数据流")],-1),H=(0,t._)("p",null,"2中的数据包不是按顺序发送的，所以2给每一个数据包（数据流）做了一个独一无二的编号，客户端还能指定数据流的优先级，优先级越高，越早响应",-1),P=(0,t._)("h3",{id:"头信息压缩",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#头信息压缩","aria-hidden":"true"},"#"),(0,t.Uk)(" 头信息压缩")],-1),q=(0,t._)("p",null,"http中很多字段是重复的，且需要每次发送。所以2就做了一点优化，引入了头信息压缩机制。一方面可以通过gzip压缩后发送；另一方面前后端还同时维护一张头信息表，通过索引来获取内容加快获取速度",-1),D=(0,t._)("h3",{id:"服务器推送",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#服务器推送","aria-hidden":"true"},"#"),(0,t.Uk)(" 服务器推送")],-1),N=(0,t._)("p",null,"2允许服务器未经请求，主动向客户端发送资源，这叫服务器推送。",-1),Z=(0,t._)("h2",{id:"避免重定向",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#避免重定向","aria-hidden":"true"},"#"),(0,t.Uk)(" 避免重定向")],-1),G=(0,t._)("p",null,"重定向是由服务器发送特殊的响应而触发的，在http中定义的响应码位3xx，在一般使用中大多数重定向为登录。我们不看影响，来看看三种重定向",-1),L=(0,t._)("ul",null,[(0,t._)("li",null,"永久重定向 301 308"),(0,t._)("li",null,"临时重定向 302 303 307"),(0,t._)("li",null,"特殊重定向 300 304（常用，资源未被修改，使用了缓存）")],-1),R=(0,t._)("h2",{id:"压缩传输的数据资源",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#压缩传输的数据资源","aria-hidden":"true"},"#"),(0,t.Uk)(" 压缩传输的数据资源")],-1),S=(0,t._)("ul",null,[(0,t._)("li",null,"响应数据压缩 ：gzip")],-1),Y=(0,t._)("h2",{id:"http-缓存",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#http-缓存","aria-hidden":"true"},"#"),(0,t.Uk)(" HTTP 缓存")],-1),j=(0,t._)("p",null,[(0,t._)("img",{src:a,alt:"缓存使用流程图"})],-1),A=(0,t._)("p",null,[(0,t.Uk)("http缓存是最常结束的缓存之一，它可细分为m"),(0,t._)("strong",null,"强制缓存"),(0,t.Uk)("和"),(0,t._)("strong",null,"协商缓存"),(0,t.Uk)("，二者最大的区别在于判断缓存命中时，浏览器是否需要向服务器端进行询问来判断是否需要重新请求")],-1),B=(0,t._)("h3",{id:"强制缓存",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#强制缓存","aria-hidden":"true"},"#"),(0,t.Uk)(" 强制缓存")],-1),F=(0,t._)("p",null,[(0,t.Uk)("和强制缓存有关的两个字段是"),(0,t._)("code",null,"expires"),(0,t.Uk)("he"),(0,t._)("code",null,"cache-control"),(0,t.Uk)("，在1.0时期会通过比较本地时间和"),(0,t._)("code",null,"expires"),(0,t.Uk)("来确定是否需要重新请求，但是这种方式存在一个很大的漏洞，如果用户对本地时间进行修改，那么对于缓存的判断就是会失误")],-1),I=(0,t._)("p",null,[(0,t.Uk)("所以在1.1时期新增了"),(0,t._)("code",null,"cache-control"),(0,t.Uk)("字段，只要设置"),(0,t._)("code",null,"maxage=1000"),(0,t.Uk)("来进行时间长度的控制，就能避免时间不同造成的问题")],-1),J=(0,t._)("p",null,[(0,t._)("strong",null,"no-cache、no-store")],-1),K=(0,t._)("p",null,"no-store 表示完全使用最新数据，不使用缓存 no-cache 表示通过与服务器协商验证缓存有效性，若未过期，则使用本地缓存",-1),M=(0,t._)("p",null,[(0,t._)("strong",null,"private、public")],-1),O=(0,t._)("p",null,"public 表示响应资源即可以被浏览器缓存，也可以被代理期缓存 private 响应资源只能被浏览器缓存，若未显示指定啧默认为prite",-1),Q=(0,t._)("p",null,[(0,t._)("strong",null,"max-age、s-maxage")],-1),V=(0,t._)("p",null,"s-maxage 表示缓存在代理服服务器上的有效性，当设置了public后，就可以设置它 且一般他会和max-age一起使用，这样来保证资源的有效性",-1),W=(0,t._)("h3",{id:"协商缓存",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#协商缓存","aria-hidden":"true"},"#"),(0,t.Uk)(" 协商缓存")],-1),X=(0,t._)("p",null,[(0,t._)("strong",null,"last-modifed")],-1),$=(0,t._)("p",null,"顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期",-1),ll=(0,t._)("p",null,[(0,t.Uk)("首先再使用写上缓存之前，服务端会将"),(0,t._)("code",null,"cache-control"),(0,t.Uk)("设置为"),(0,t._)("code",null,"no-cache"),(0,t.Uk)("，然后获取文件的最后修改时间，放到响应头的"),(0,t._)("code",null,"last-modified"),(0,t.Uk)("中，客户端拿到后，入伙刷新页面，就会在请求头重带上一个"),(0,t._)("code",null,"if-modified-since"),(0,t.Uk)("字段，值和"),(0,t._)("code",null,"last-modified"),(0,t.Uk)("一样，这时候服务端比较两个值，后返回新资源，还是返回304不修改，将响应体重定向到本地缓存上")],-1),el=(0,t._)("p",null,"last-modifed的不足：",-1),nl=(0,t._)("ol",null,[(0,t._)("li",null,"获取时间戳其文件的修改单位是秒，如果文件修改非常快，这个缓存就存在有效性问题"),(0,t._)("li",null,"只改文件名，没动内容也会更新时间")],-1),tl=(0,t._)("p",null,[(0,t._)("strong",null,"Etag")],-1),al=(0,t._)("p",null,[(0,t.Uk)("为了弥补不足，1.1新增了"),(0,t._)("code",null,"Etag"),(0,t.Uk)("，"),(0,t._)("code",null,"Etag"),(0,t.Uk)("会根据文件内容的不同生成一个hash字符串。"),(0,t._)("code",null,"Etag"),(0,t.Uk)("比"),(0,t._)("code",null,"last-modified"),(0,t.Uk)("的优先级更高，做法和之前类似，客户端也会返回一个同值的"),(0,t._)("code",null,"if-none-match"),(0,t.Uk)("来给服务端进行判断")],-1),il=(0,t._)("p",null,"Etag的不足",-1),dl=(0,t._)("ol",null,[(0,t._)("li",null,"需要服务器消耗资源进行hash计算")],-1),ul=(0,t._)("h2",{id:"cdn-缓存",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#cdn-缓存","aria-hidden":"true"},"#"),(0,t.Uk)(" cdn 缓存")],-1),rl=(0,t._)("p",null,"cdn为什么设计成和主站域名不同？",-1),hl=(0,t._)("ol",null,[(0,t._)("li",null,"避免对静态资源的请求携带不必要的Cookie信息"),(0,t._)("li",null,"考虑浏览器对同一域名下并发请求的限制")],-1),_l={},cl=(0,n(3744).Z)(_l,[["render",function(l,e){return(0,t.wg)(),(0,t.iD)(t.HY,null,[i,d,u,r,h,_,c,s,o,p,k,g,U,f,x,b,m,v,E,T,C,w,y,z,H,P,q,D,N,Z,G,L,R,S,Y,j,A,B,F,I,J,K,M,O,Q,V,W,X,$,ll,el,nl,tl,al,il,dl,ul,rl,hl],64)}]])},3744:(l,e)=>{e.Z=(l,e)=>{for(const[n,t]of e)l[n]=t;return l}},5867:(l,e,n)=>{l.exports=n.p+"assets/img/2.ab2148ae.png"}}]);