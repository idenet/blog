"use strict";(self.webpackChunkstudy_note=self.webpackChunkstudy_note||[]).push([[7715],{8997:(e,l,i)=>{i.r(l),i.d(l,{data:()=>a});const a={key:"v-3847f68b",path:"/performance/render.html",title:"渲染优化",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"关键渲染路径优化",slug:"关键渲染路径优化",children:[{level:3,title:"优化 DOM",slug:"优化-dom",children:[]},{level:3,title:"优化 CSS",slug:"优化-css",children:[]},{level:3,title:"优化 js的使用",slug:"优化-js的使用",children:[]}]},{level:2,title:"js 执行优化",slug:"js-执行优化",children:[]},{level:2,title:"计算样式优化",slug:"计算样式优化",children:[{level:3,title:"减少要计算样式的元素数量",slug:"减少要计算样式的元素数量",children:[]}]},{level:2,title:"页面布局的重绘优化",slug:"页面布局的重绘优化",children:[]}],filePathRelative:"performance/render.md",git:{updatedTime:1639231809e3}}},5531:(e,l,i)=>{i.r(l),i.d(l,{default:()=>d});const a=(0,i(6252).uE)('<h1 id="渲染优化" tabindex="-1"><a class="header-anchor" href="#渲染优化" aria-hidden="true">#</a> 渲染优化</h1><p>整个url过程的上半段是讲完了，下半段是浏览器获取资源渲染的过程，这个过程主要分为以下步骤</p><ol><li>处理<code>html</code>标记并构建<code>DOM</code>树</li><li>处理<code>CSS</code>并构建<code>CSSOM</code>树</li><li>将<code>DOM</code>和<code>CSSOM</code>合并成一个render tree</li><li>根据渲染树来布局，以计算每个节点的几何信息</li><li>将各个节点会知道屏幕上</li></ol><p>优化关键渲染路径就就是指最大限度缩短执行上述第一步至第五步耗费的总时间</p><h2 id="关键渲染路径优化" tabindex="-1"><a class="header-anchor" href="#关键渲染路径优化" aria-hidden="true">#</a> 关键渲染路径优化</h2><h3 id="优化-dom" tabindex="-1"><a class="header-anchor" href="#优化-dom" aria-hidden="true">#</a> 优化 DOM</h3><p>让HTML文件的尺寸尽可能的小。这个优化其实在webpack的插件中都有做，比如</p><ul><li>缩小文件尺寸 (minify)</li><li>使用gzip压缩 (compress)</li><li>使用缓存 (http cache)</li></ul><h3 id="优化-css" tabindex="-1"><a class="header-anchor" href="#优化-css" aria-hidden="true">#</a> 优化 CSS</h3><p><strong>阻塞渲染的 CSS</strong></p><p>css是关键资源，所以阻塞渲染也不奇怪，所以对于css，可以将css放到html中，或者使用media处理不需要在当前屏幕加载的资源</p><p><strong>避免在css中使用@import</strong></p><p>使用import会加长额外的关键路径长度</p><h3 id="优化-js的使用" tabindex="-1"><a class="header-anchor" href="#优化-js的使用" aria-hidden="true">#</a> 优化 js的使用</h3><p>通常这些文件都要尽可能的小，在此之外，还可以使用</p><ol><li>defer延迟加载，告诉浏览器不要等待脚本，脚本会在后台下载，等DOM树构建完成之后，才能执行，但是还是按照加载顺序执行</li><li>async 延迟加载， 但是不能保证执行顺序。</li><li>preload 利用空闲时间预加载指定的资源</li><li>prefetch 预加载将来可能要用到的资源（非当前页面资源）</li><li>将 js放到dom节点的最后</li></ol><h2 id="js-执行优化" tabindex="-1"><a class="header-anchor" href="#js-执行优化" aria-hidden="true">#</a> js 执行优化</h2><ol><li>如果需要动画，使用<code>requestAnimationFrame</code>来执行动画</li><li>如果需要一些长时间纯计算的工作，迁移到<code>web worker</code>上处理</li><li>js 防抖和节流</li></ol><h2 id="计算样式优化" tabindex="-1"><a class="header-anchor" href="#计算样式优化" aria-hidden="true">#</a> 计算样式优化</h2><h3 id="减少要计算样式的元素数量" tabindex="-1"><a class="header-anchor" href="#减少要计算样式的元素数量" aria-hidden="true">#</a> 减少要计算样式的元素数量</h3><p>首先我们要知道与计算样式的一条重要机制：<strong>css引擎在查找样式表时，对每条规则的匹配顺序是从右向左的</strong>，而且如果是li标签会一个个遍历查找，会非常慢</p><p>因此在样式计算上总结以下几点实战</p><ol><li>使用类选择器替代标签选择器</li><li>避免使用通配符做选择器</li><li>降低选择器的复杂性</li></ol><p>因此 总结以上，社区剔除了一种css书写规范来避免这些问题，即 BEM</p><ul><li>中划线(-) 作为连字符使用，表示元素多个单词之间的连字符</li><li>双下划线(__) 作为连接块与块的子元素</li><li>单下划线(_) 作为描述一个块或者其它子元素的状态</li></ul><p>如</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>type-block__element_modifier\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="页面布局的重绘优化" tabindex="-1"><a class="header-anchor" href="#页面布局的重绘优化" aria-hidden="true">#</a> 页面布局的重绘优化</h2><p>除去页面布局，触发页面的重绘可分为三类</p><ul><li>dom元素几何属性的修改</li><li>更改dom树的结构</li><li>获取某些特性的属性值操作</li></ul>',30),r={},d=(0,i(3744).Z)(r,[["render",function(e,l){return a}]])},3744:(e,l)=>{l.Z=(e,l)=>{for(const[i,a]of l)e[i]=a;return e}}}]);